% !TeX spellcheck = pl_PL
\chapter{Implementacja}\label{ch:implementation}
\section{Wykorzystywane środowiska i~narzędzia programistyczne}\label{sec:dev-tools}

Podczas wyboru języków programowania, z~użyciem których miał zostać zaimplementowany system, postawiono następujące kryteria:

\begin{itemize}
    \item ścisła kontrola typów
    \item dobre wsparcie dla paradygmatu programowania obiektowego
    \item niezależność języka od platformy
    \item bogaty ekosystem
\end{itemize}

Wybrane języki spełniające te kryteria to:

\begin{itemize}
    \item w~warstwie backendu Java\cite{tech:java}~- stworzony przez Sun Microsystems język kompilowalny do kodu bajtowego, który jest wykonywany na maszynie wirtualnej
    \item w~warstwie frontendu Typescript\cite{tech:typescript}~- stworzony przez Microsoft język otwartoźródłowy kompilowalny do języka JavaScript\cite{tech:javascript}
\end{itemize}

Powyższy wybór zaowocował decyzją o~zastosowaniu Angulara\cite{tech:angular} jako wiodącej frontendowej platformy programistycznej
i~Springa\cite{tech:spring} jako wiodącej backendowej platformy programistycznej.
Wspomniane platformy cieszą się bardzo dużą popularnością, a~ich dojrzałość sprawia,
że nadają się zarówno przy tworzeniu niewielkich aplikacji jak i~systemów klasy enterprise.

\par
Podczas projektu witryny internetowej kod, który jest wykonywany po stronie przeglądarki zwykle jest napisany w technologiach HTML, CSS\cite{tech:html-css} i JavaScript\cite{tech:javascript}.
Jak już wspomniano zamiast języka JavaScript wykorzystano TypeScript, natomiast zamiast CSS postanowiono wykorzystać SASS\cite{tech:sass}, który rozszerza funkcjonalność CSS.

\par
System został zaprojektowany tak, żeby wykorzystać cechy relacyjnych baz danych,
więc podczas wyboru systemu zarządzania bazą danych pod uwagę wzięto tylko relacyjne bazy danych.
Rozważano przede wszystkim systemy PostgreSQL\cite{tech:postgresql} i~MySQL\cite{tech:mysql}.
Z~punktu widzenia funkcjonalności potrzebnych w~implementowanej aplikacji oba systemy systemy zarządzania relacyjną bazą danych (ang. Relational Database Management System~- RDBMS) wypadają równie dobrze,
jednakże ostatecznie wybrano PostgreSQL ze względu na mniej restrykcyjną licencję wykorzystania systemu nawet w~rozwiązaniach komercyjnych o~zamkniętym kodzie.
Dodatkowo postanowiono wykorzystać bibliotekę Liquibase\cite{tech:liquibase} do zarządzania zmianami schematu bazy.

\par
Do implementacji architektury mikroserwisów postanowiono wykorzystać stos technologii Netflix OSS\cite{tech:netflix-oss}.
Jest to dojrzały, prosty do wykorzystania w implementacji stos technologii mikroserwisowych,
dla którego możliwa jest ścisła integracja ze Springiem poprzez wykorzystania projektu Spring Cloud Netflix\cite{tech:spring-cloud-netflix}.
W skład tego stosu wchodzą przede wszystkim:
\begin{itemize}
    \item Eureka\cite{tech:netflix-eureka}~- serwis typu discovery
    \item Zuul\cite{tech:netflix-zuul}~- serwis zapewniający dynamiczne przekierowywanie żądań z bramy aplikacji do poszczególnych mikroserwisów
    \item Ribbon\cite{tech:netflix-ribbon}~- serwis zapewniający równoważenie obciążenia podczas wyboru mikroserwisu, który odpowie na żądanie
\end{itemize}

\par
Ze względu na wykorzystanie architektury mikroserwisowej zdecydowano się na autentykację użytkowników z użyciem tokenów JWT\cite{url:jwt},
ponieważ jest to bezstanowy mechanizm, który można bezproblemowo wykorzystywać w środowisku rozproszonym.

\par
W celu przyspieszenia rozwoju aplikacji postanowiono wykorzystać generator szkieletu aplikacji JHipster\cite{tech:jhipster}.
Korzystając z autorskiego języka domenowego JHipstera możliwe jest zdefiniowanie konfiguracji systemu mikroserwisowego w oparciu o stos technologii Netflix OSS oraz encji przypisanych do konkretnych serwisów.
Wykorzystaną konfigurację przedstawiono w dodatku \ref{app:jdl}, jednakże w celu zwiększenia czytelności postanowiono pominąć opis encji, które zostały bezpośrednio oparte na kategoriach opisanych w rozdziale \ref{sec:database}.
Na podstawie zdefiniowanej konfiguracji wygenerowane zostały szkielety serwisów zapewniające zarządzanie infrastrukturą mikroserwisów, autoryzację i autentykację użytkowników oraz przeprowadzanie podstawowych operacji CRUD na encjach.

\par
Dodatkowo postanowiono wykorzystać następujące narzędzia niezwiązane bezpośrednio z implementacją:
\begin{itemize}
    \item Docker\cite{tech:docker}~- system konteneryzacji pozwalający uprościć proces wdrażania aplikacji z wykorzystaniem konfiguracji niezależnej od środowiska
    \item Docker Compose\cite{tech:docker-compose}~- narzędzie upraszczające zarządzanie wielokontenerowym środowiskiem aplikacji skonteneryzowanych
    \item Git\cite{tech:git}~- rozproszony system kontroli wersji wykorzystywany do zarządzania zmianami w kodzie
    \item Gitlab Pipelines\cite{tech:gitlab-pipelines}~- narzędzie wspomagające proces ciągłej integracji
\end{itemize}

\section{Zakres implementacji}\label{sec:implementation-scope}

W wyniku analizy założeń projektowych przedstawionych w rozdziale \ref{ch:design-assumptions} stwierdzono,
że osiągnięcie minimalnego funkcjonalnego stanu produktu (ang. Minimum Viable Product~- MVP)
wymaga zaimplementowania całego modelu domeny omówionego w projekcie bazy danych w rozdziale \ref{sec:database}.
Natomiast w kwestii dostępu do systemu, w celu osiągnięcia MVP wystarczy, żeby bezpośredni dostęp mieli tylko dietetycy i administratorzy,
a pacjenci otrzymywali skomponowane diety na adres mailowy, który podali dietetykowi.

\par
Ze względu na przetwarzanie wrażliwych danych osobowych, konieczne jest zawarcie w witrynie internetowej polityki prywatności.
Na rzecz osiągnięcia MVP w przygotowywanej implementacji postanowiono wykorzystać szablon udostępniany przez firmę ogicom.pl\cite{url:ogicom-privacy-policy}.
Jednakże należy podkreślić, że autor niniejszej pracy inżynierskiej nie posiada wykształcenia prawniczego
i należy traktować przedstawioną politykę prywatności jedynie jako wersję roboczą,
a przed komercyjnym wdrożeniem systemu należałoby zasięgnąć porady w kancelarii prawnej oferującej doradztwo prawne z zakresu przetwarzania i ochrony danych osobowych.
%Wykorzystany szablon przedstawiony został w dodatku \ref{app:privacy-policy}.

\section{Architektura systemu}\label{sec:system-architecture}
\todo{opisać stack netflix oss}
\todo{diagram rozmieszczenia}
\section{Instalacja oprogramowania}\label{sec:software-installation}
\subsection{Wymagania wstępne}\label{subsec:prerequirements}
Przed przystąpieniem do wykonywania kolejnych kroków należy się upewnić, że następujące narzędzia są zainstalowane:
\begin{itemize}
    \item Open JDK 11 (https://adoptopenjdk.net/?variant=openjdk11)
    \item Node.js 10 lub nowsza wersja LTS (https://nodejs.org/en/)
    \item Docker 19.03 + Docker Compose 2 (https://docs.docker.com/install/)
\end{itemize}

\subsection{Instalacja}\label{subsec:installation}

Aby zbudować i~uruchomić projekt z wykorzystaniem Dockera należy z~poziomu głównego katalogu projektu
wykonać polecenia przedstawione na listingu \ref{listing:komilacja-i-uruchomienie}.
\begin{listing}[h!]
    \begin{minted}{bash}
        cd gateway
        npm install
        sh gradlew bootJar -Pprod jibDockerBuild
        cd ../products
        sh gradlew bootJar -Pprod jibDockerBuild
        cd ../recipes
        sh gradlew bootJar -Pprod jibDockerBuild
        cd ../mealplans
        sh gradlew bootJar -Pprod jibDockerBuild
        cd ../appointments
        sh gradlew bootJar -Pprod jibDockerBuild
        cd ../docker-compose
        sh docker-compose up
    \end{minted}
    \centering\caption{Skrypt kompilujący wszystkie mikroserwisy i~uruchamiający aplikację na Dockerze (opr. wł.)}\label{listing:komilacja-i-uruchomienie}
\end{listing}

Alternatywnie, dla celów deweloperskich można zastosować uproszczony proces nie wykorzystujący Dockera.
W tym celu należy najpierw uruchomić JHipster Registry wykonując polecenie z~poziomu głównego katalogu projektu
wykonać polecenia przedstawione na listingu \ref{listing:service-discovery}.
\begin{listing}[h!]
    \begin{minted}{bash}
        cd service-discovery
        java -jar ./jhipster-registry-5.0.2.jar --spring.profiles.active=dev --spring.security.user.password=admin --spring.cloud.config.server.composite.0.type=git --spring.cloud.config.server.composite.0.uri= https://github.com/jhipster/jhipster-registry-sample-config
    \end{minted}
    \centering\caption{Uruchamianie JHipster Registry (opr. wł.)}\label{listing:service-discovery}
\end{listing}

Następnie z~poziomu katalogu każdego z~serwisów (gateway, products, recipes, mealplans, appointments)
należy wykonać polecenie uruchamiające Gradle Wrapper przedstawione na listingu \ref{listing:run-gradle-wrapper}.
\begin{listing}[h!]
    \begin{minted}{bash}
        ./gradlew
    \end{minted}
    \centering\caption{Uruchamianie Gradle Wrapper (opr. wł.)}\label{listing:run-gradle-wrapper}
\end{listing}

Po uruchomieniu wszystkich serwisów aplikacja będzie dostępna pod adresem \textit{localhost:8080}.

\section{Prezentacja aplikacji}\label{sec:app-presentation}
\todo{podstawowy opis poruszania się po aplikacji, zrzuty ekranu z~kilku najważniejszych widoków}
%\todo{implementacja w~kodzie: obliczanie podstawowych wartości odżywczych w~przepisie, wyświetlanie spełnienia norm odżywczych w~jadłospisie, wersjonowanie produktów i~przepisów, generowanie listy zakupów i~jadłospisu do wydruku, wykres BMI}

\section{Dokumentacja kodu}\label{sec:code-documentation}
\todo{javadoc, swagger, jdl}
\section{Testy}\label{sec:tests}
\todo{przykładowe testy jednostkowe i~integracyjne}
\todo{testy użyteczności}
\thispagestyle{normal}
